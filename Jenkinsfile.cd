import java.util.regex.Pattern // Giữ lại, không hại gì

pipeline {
    agent any
    
    parameters {
        string(name: 'API_GATEWAY_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for api-gateway. Use "main" for latest, or a specific commit ID.')
        string(name: 'ADMIN_SERVER_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for admin-server.')
        string(name: 'CUSTOMERS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for customers-service.')
        string(name: 'DISCOVERY_SERVER_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for discovery-server.')
        string(name: 'VETS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for vets-service.')
        string(name: 'VISITS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for visits-service.')
        string(name: 'GENAI_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for genai-service.')
        string(name: 'TARGET_NAMESPACE', defaultValue: 'petclinic-devtest', description: 'Kubernetes namespace to deploy to.')
    }
    
    environment {
        DOCKER_HUB_CREDS = credentials('dockerhub')
        // KHAI BÁO LẠI DOCKER_HUB_USERNAME Ở ĐÂY
        // Hoặc chúng ta sẽ truy cập DOCKER_HUB_CREDS_USR trực tiếp trong script block nếu cần
    }
    
    stages {
        stage('Checkout Kubernetes Manifests') {
            steps {
                checkout([$class: 'GitSCM', 
                    branches: [[name: 'main']], 
                    userRemoteConfigs: [[url: 'https://github.com/OpsInUs/Petclinic-02.git']]
                ])
            }
        }
        
        stage('Prepare Image Tags') {
            steps {
                script {
                    def localTagMapForInfo = [:] 

                    def servicesParams = [
                        'api-gateway'     : params.API_GATEWAY_BRANCH,
                        'admin-server'    : params.ADMIN_SERVER_BRANCH,
                        'customers-service': params.CUSTOMERS_SERVICE_BRANCH,
                        'discovery-server': params.DISCOVERY_SERVER_BRANCH,
                        'vets-service'    : params.VETS_SERVICE_BRANCH,
                        'visits-service'  : params.VISITS_SERVICE_BRANCH,
                        'genai-service'   : params.GENAI_SERVICE_BRANCH
                    ]

                    servicesParams.each { serviceName, branchOrCommit ->
                        echo "Processing parameters for service: ${serviceName}, branch/commit input: ${branchOrCommit}"
                        def imageTag
                        if (branchOrCommit.toLowerCase() == 'main' || branchOrCommit.toLowerCase() == 'latest') {
                            imageTag = 'latest'
                        } else if (branchOrCommit.matches('[a-f0-9]{7,40}')) {
                            imageTag = branchOrCommit
                            echo "Using direct commit ID '${imageTag}' for ${serviceName}."
                        } else {
                            try {
                                sh "git fetch origin \"${branchOrCommit}\" --depth=1"
                                imageTag = sh(script: "git rev-parse --short \"origin/${branchOrCommit}\"", returnStdout: true).trim()
                                echo "Resolved branch '${branchOrCommit}' to commit ID '${imageTag}' for ${serviceName}."
                            } catch (Exception e) {
                                echo "Warning: Could not resolve branch '${branchOrCommit}' for service ${serviceName}. Defaulting to 'latest'. Error: ${e.getMessage()}"
                                imageTag = 'latest'
                            }
                        }
                        localTagMapForInfo[serviceName] = imageTag
                        env["TAG_${serviceName.toUpperCase().replace('-', '_')}"] = imageTag
                        echo "Stored image tag for ${serviceName} in env.TAG_${serviceName.toUpperCase().replace('-', '_')}: ${imageTag}"
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    sh "kubectl create namespace \"${params.TARGET_NAMESPACE}\" --dry-run=client -o yaml | kubectl apply -f -"
                    
                    def manifestFiles = [
                        'discovery-server',
                        'admin-server',
                        'api-gateway',
                        'customers-service',
                        'vets-service',
                        'visits-service',
                        'genai-service'
                    ]

                    manifestFiles.each { serviceKey ->
                        def serviceEnvKeyForTag = "TAG_${serviceKey.toUpperCase().replace('-', '_')}"
                        def currentImageTag = env[serviceEnvKeyForTag] ?: 'latest' 
                        
                        def manifestFile = "k8s/${serviceKey}.yaml"
                        if (fileExists(manifestFile)) {
                            echo "Deploying ${manifestFile} with image tag ${currentImageTag} for service ${serviceKey}..."
                            
                            // SỬ DỤNG DOCKER_HUB_CREDS_USR TRỰC TIẾP TỪ CREDENTIALS
                            // KHÔNG CẦN KHAI BÁO LẠI DOCKER_HUB_USERNAME TRONG environment {}
                            def shellDockerHubUsername = DOCKER_HUB_CREDS_USR 
                            def shellImageTag = currentImageTag 
                            def shellTargetNamespace = params.TARGET_NAMESPACE 

                            sh """
                                set -x
                                export SED_DOCKER_HUB_USERNAME_EXPORTED="${shellDockerHubUsername}"
                                export SED_IMAGE_TAG_EXPORTED="${shellImageTag}"
                                export SED_TARGET_NAMESPACE_EXPORTED="${shellTargetNamespace}"

                                cat "${manifestFile}" | \\
                                sed \\
                                    -e 's~\\\$\\\\{\\s*DOCKER_HUB_USERNAME\\s*\\}~'"\$SED_DOCKER_HUB_USERNAME_EXPORTED"'~g' \\
                                    -e 's~\\\$\\\\{\\s*TAG\\s*\\}~'"\$SED_IMAGE_TAG_EXPORTED"'~g' \\
                                    -e 's~namespace:\\s*petclinic~namespace: '"\$SED_TARGET_NAMESPACE_EXPORTED"'~g' \\
                                    > manifest_temp.yaml
                                
                                echo "--- PROCESSED MANIFEST for ${serviceKey} (Jenkins Log) ---"
                                cat manifest_temp.yaml
                                echo "--- END PROCESSED MANIFEST (Jenkins Log) ---"
                                
                                kubectl apply -n "\$SED_TARGET_NAMESPACE_EXPORTED" -f manifest_temp.yaml
                                set +x
                            """
                            
                            if (serviceKey == 'discovery-server' || serviceKey == 'config-server') {
                                echo "Waiting for ${serviceKey} to stabilize..."
                                sh "sleep 30"
                            } else {
                                sh "sleep 5"
                            }
                        } else {
                            echo "Warning: Manifest file ${manifestFile} not found. Skipping."
                        }
                    }
                    
                    def apiGatewayNodePortManifest = "k8s/api-gateway-nodeport.yaml"
                    if (fileExists(apiGatewayNodePortManifest)) {
                        def shellTargetNamespaceForNodePort = params.TARGET_NAMESPACE
                        sh """
                            set -x
                            export SED_TARGET_NAMESPACE_NODEPORT_EXPORTED="${shellTargetNamespaceForNodePort}"
                            cat "${apiGatewayNodePortManifest}" | \\
                            sed -e 's~namespace:\\s*petclinic~namespace: '"\$SED_TARGET_NAMESPACE_NODEPORT_EXPORTED"'~g' \\
                                > nodeport_temp.yaml
                            
                            kubectl apply -n "\$SED_TARGET_NAMESPACE_NODEPORT_EXPORTED" -f nodeport_temp.yaml
                            set +x
                        """
                    } else {
                        echo "Warning: API Gateway NodePort manifest ${apiGatewayNodePortManifest} not found."
                    }

                    def workerNodeIP = sh(script: 'kubectl get nodes -l \'!node-role.kubernetes.io/control-plane\' -o jsonpath=\'{.items[0].status.addresses[?(@.type=="InternalIP")].address}\'', returnStdout: true).trim()
                    def nodePort = sh(script: "kubectl get svc api-gateway-nodeport -n \"${params.TARGET_NAMESPACE}\" -o jsonpath='{.spec.ports[0].nodePort}'", returnStdout: true).trim()

                    if (workerNodeIP.isEmpty() || nodePort.isEmpty()) {
                        echo "Could not determine Worker Node IP or NodePort. Please check manually."
                    } else {
                        echo "====================================================="
                        echo "Ứng dụng Petclinic đã được triển khai vào namespace: ${params.TARGET_NAMESPACE}"
                        echo "Bạn có thể truy cập ứng dụng tại: http://${workerNodeIP}:${nodePort}"
                        // ... (phần echo thông tin hosts)
                    }
                }
            }
        }
    }
    
    post {
        always {
            echo "CD Pipeline finished."
            sh "rm -f manifest_temp.yaml nodeport_temp.yaml || true"
        }
    }
}