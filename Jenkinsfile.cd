pipeline {
    agent any
    
    parameters {
        string(name: 'API_GATEWAY_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for api-gateway. Use "main" for latest, or a specific commit ID.')
        string(name: 'ADMIN_SERVER_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for admin-server.')
        string(name: 'CUSTOMERS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for customers-service.')
        string(name: 'DISCOVERY_SERVER_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for discovery-server.')
        string(name: 'VETS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for vets-service.')
        string(name: 'VISITS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for visits-service.')
        string(name: 'GENAI_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for genai-service.')
        string(name: 'TARGET_NAMESPACE', defaultValue: 'petclinic-devtest', description: 'Kubernetes namespace to deploy to.')
    }
    
    environment {
        DOCKER_HUB_CREDS = credentials('dockerhub')
        // DOCKER_HUB_USERNAME sẽ được truy cập trực tiếp từ DOCKER_HUB_CREDS_USR
    }
    
    stages {
        stage('Checkout Kubernetes Manifests') {
            steps {
                checkout([$class: 'GitSCM', 
                    branches: [[name: 'main']], 
                    userRemoteConfigs: [[url: 'https://github.com/OpsInUs/Petclinic-02.git']]
                ])
            }
        }
        
        stage('Prepare Image Tags') {
            steps {
                script {
                    // Sử dụng biến cục bộ để xây dựng map, sau đó lưu từng giá trị vào env
                    def localTagMap = [:]

                    def servicesParams = [
                        'api-gateway'     : params.API_GATEWAY_BRANCH,
                        'admin-server'    : params.ADMIN_SERVER_BRANCH,
                        'customers-service': params.CUSTOMERS_SERVICE_BRANCH,
                        'discovery-server': params.DISCOVERY_SERVER_BRANCH,
                        'vets-service'    : params.VETS_SERVICE_BRANCH,
                        'visits-service'  : params.VISITS_SERVICE_BRANCH,
                        'genai-service'   : params.GENAI_SERVICE_BRANCH
                    ]

                    servicesParams.each { serviceName, branchOrCommit ->
                        echo "Processing parameters for service: ${serviceName}, branch/commit input: ${branchOrCommit}"
                        def imageTag
                        if (branchOrCommit.toLowerCase() == 'main' || branchOrCommit.toLowerCase() == 'latest') {
                            imageTag = 'latest'
                        } else if (branchOrCommit.matches('[a-f0-9]{7,40}')) {
                            imageTag = branchOrCommit
                            echo "Using direct commit ID '${imageTag}' for ${serviceName}."
                        } else {
                            try {
                                // Đảm bảo không có lỗi nếu branchOrCommit chứa ký tự đặc biệt cho shell
                                sh "git fetch origin \"${branchOrCommit}\" --depth=1"
                                imageTag = sh(script: "git rev-parse --short \"origin/${branchOrCommit}\"", returnStdout: true).trim()
                                echo "Resolved branch '${branchOrCommit}' to commit ID '${imageTag}' for ${serviceName}."
                            } catch (Exception e) {
                                echo "Warning: Could not resolve branch '${branchOrCommit}' for service ${serviceName}. Defaulting to 'latest'. Error: ${e.getMessage()}"
                                imageTag = 'latest'
                            }
                        }
                        localTagMap[serviceName] = imageTag // Dùng cho env.TAG_SERVICES_JSON
                        // Tạo biến môi trường riêng cho mỗi service để sed dễ sử dụng
                        env["TAG_${serviceName.toUpperCase().replace('-', '_')}"] = imageTag
                        echo "Stored image tag for ${serviceName}: ${imageTag}"
                    }
                    // Lưu danh sách các service key có tag vào env (dưới dạng JSON để dễ parse nếu cần)
                    // Hoặc đơn giản là lặp lại servicesParams.keySet() trong stage sau
                    // import groovy.json.JsonOutput
                    // env.TAG_MAP_JSON = JsonOutput.toJson(localTagMap) 
                    // Hiện tại chúng ta dùng env["TAG_SERVICE_NAME"] nên không cần TAG_MAP_JSON nữa
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    sh "kubectl create namespace \"${params.TARGET_NAMESPACE}\" --dry-run=client -o yaml | kubectl apply -f -"
                    
                    def manifestFiles = [
                        'discovery-server',
                        // 'config-server', // Bỏ qua nếu không có manifest
                        'admin-server',
                        'api-gateway',
                        'customers-service',
                        'vets-service',
                        'visits-service',
                        'genai-service'
                    ]

                    manifestFiles.each { serviceKey ->
                        def serviceEnvKeyForTag = "TAG_${serviceKey.toUpperCase().replace('-', '_')}"
                        // Lấy imageTag từ biến env đã đặt ở stage trước
                        def currentImageTag = env[serviceEnvKeyForTag]

                        if (currentImageTag == null) {
                            echo "Warning: No specific image tag found in env for '${serviceKey}' (env var ${serviceEnvKeyForTag}). Defaulting to 'latest'."
                            currentImageTag = 'latest' // Fallback an toàn
                        }
                        
                        def manifestFile = "k8s/${serviceKey}.yaml"
                        if (fileExists(manifestFile)) {
                            echo "Deploying ${manifestFile} with image tag ${currentImageTag} for service ${serviceKey}..."
                            sh $/                            
                                set -x
                                export SED_DOCKER_HUB_USERNAME="${DOCKER_HUB_CREDS_USR}"
                                export SED_IMAGE_TAG="${currentImageTag}"
                                export SED_TARGET_NAMESPACE="${params.TARGET_NAMESPACE}"

                                cat "${manifestFile}" | \
                                sed -e 's~\${\s*DOCKER_HUB_USERNAME\s*}~'"\$SED_DOCKER_HUB_USERNAME"'~g' \
                                    -e 's~\${\s*TAG\s*}~'"\$SED_IMAGE_TAG"'~g' \
                                    -e 's~namespace:\s*petclinic~namespace: '"\$SED_TARGET_NAMESPACE"'~g' > manifest_temp.yaml
                                
                                echo "--- PROCESSED MANIFEST for ${serviceKey} (Jenkins Log) ---"
                                cat manifest_temp.yaml
                                echo "--- END PROCESSED MANIFEST (Jenkins Log) ---"
                                
                                kubectl apply -n "${params.TARGET_NAMESPACE}" -f manifest_temp.yaml
                                set +x
                            /$
                            
                            if (serviceKey == 'discovery-server' || serviceKey == 'config-server') {
                                echo "Waiting for ${serviceKey} to stabilize..."
                                sh "sleep 30" // Cân nhắc dùng: kubectl rollout status deployment/...
                            } else {
                                sh "sleep 5"
                            }
                        } else {
                            echo "Warning: Manifest file ${manifestFile} not found. Skipping."
                        }
                    }
                    
                    // API Gateway NodePort
                    def apiGatewayNodePortManifest = "k8s/api-gateway-nodeport.yaml"
                    if (fileExists(apiGatewayNodePortManifest)) {
                        sh $/
                            set -x
                            export SED_TARGET_NAMESPACE="${params.TARGET_NAMESPACE}"
                            cat "${apiGatewayNodePortManifest}" | \
                            sed -e 's~namespace:\s*petclinic~namespace: '"\$SED_TARGET_NAMESPACE"'~g' > nodeport_temp.yaml
                            
                            kubectl apply -n "${params.TARGET_NAMESPACE}" -f nodeport_temp.yaml
                            set +x
                        /$
                    } else {
                        echo "Warning: API Gateway NodePort manifest ${apiGatewayNodePortManifest} not found."
                    }

                    // Sửa lỗi quoting cho jsonpath
                    def workerNodeIP = sh(script: 'kubectl get nodes -l \'!node-role.kubernetes.io/control-plane\' -o jsonpath=\'{.items[0].status.addresses[?(@.type=="InternalIP")].address}\'', returnStdout: true).trim()
                    def nodePort = sh(script: "kubectl get svc api-gateway-nodeport -n \"${params.TARGET_NAMESPACE}\" -o jsonpath='{.spec.ports[0].nodePort}'", returnStdout: true).trim()

                    if (workerNodeIP.isEmpty() || nodePort.isEmpty()) {
                        echo "Could not determine Worker Node IP or NodePort. Please check manually."
                    } else {
                        echo "====================================================="
                        echo "Ứng dụng Petclinic đã được triển khai vào namespace: ${params.TARGET_NAMESPACE}"
                        echo "Bạn có thể truy cập ứng dụng tại: http://${workerNodeIP}:${nodePort}"
                        echo "Nếu truy cập từ máy local, hãy thêm dòng sau vào file /etc/hosts (hoặc C:\\Windows\\System32\\drivers\\etc\\hosts trên Windows):"
                        echo "${workerNodeIP} petclinic-${params.TARGET_NAMESPACE}.local"
                        echo "Sau đó, bạn có thể truy cập ứng dụng tại: http://petclinic-${params.TARGET_NAMESPACE}.local:${nodePort}"
                        echo "====================================================="
                    }
                }
            }
        }
    }
    
    post {
        always {
            echo "CD Pipeline finished."
            sh "rm -f manifest_temp.yaml nodeport_temp.yaml || true" // Thêm || true để không lỗi nếu file không tồn tại
        }
    }
}