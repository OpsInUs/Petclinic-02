import java.util.regex.Pattern

pipeline {
    agent any
    
    parameters {
        string(name: 'API_GATEWAY_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for api-gateway. Use "main" for latest, or a specific commit ID.')
        string(name: 'ADMIN_SERVER_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for admin-server.')
        string(name: 'CUSTOMERS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for customers-service.')
        string(name: 'DISCOVERY_SERVER_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for discovery-server.')
        string(name: 'VETS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for vets-service.')
        string(name: 'VISITS_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for visits-service.')
        string(name: 'GENAI_SERVICE_BRANCH', defaultValue: 'main', description: 'Branch/CommitID for genai-service.')
        string(name: 'TARGET_NAMESPACE', defaultValue: 'petclinic-devtest', description: 'Kubernetes namespace to deploy to.')
    }
    
    environment {
        DOCKER_HUB_CREDS = credentials('dockerhub')
    }
    
    stages {
        stage('Checkout Kubernetes Manifests') {
            steps {
                checkout([$class: 'GitSCM', 
                    branches: [[name: 'main']], 
                    userRemoteConfigs: [[url: 'https://github.com/OpsInUs/Petclinic-02.git']]
                ])
            }
        }
        
        stage('Prepare Image Tags') {
            steps {
                script {
                    def localTagMap = [:]
                    def servicesParams = [
                        'api-gateway'     : params.API_GATEWAY_BRANCH,
                        'admin-server'    : params.ADMIN_SERVER_BRANCH,
                        'customers-service': params.CUSTOMERS_SERVICE_BRANCH,
                        'discovery-server': params.DISCOVERY_SERVER_BRANCH,
                        'vets-service'    : params.VETS_SERVICE_BRANCH,
                        'visits-service'  : params.VISITS_SERVICE_BRANCH,
                        'genai-service'   : params.GENAI_SERVICE_BRANCH
                    ]
                    servicesParams.each { serviceName, branchOrCommit ->
                        echo "Processing parameters for service: ${serviceName}, branch/commit input: ${branchOrCommit}"
                        def imageTag
                        if (branchOrCommit.toLowerCase() == 'main' || branchOrCommit.toLowerCase() == 'latest') {
                            imageTag = 'latest'
                        } else if (branchOrCommit.matches('[a-f0-9]{7,40}')) {
                            imageTag = branchOrCommit
                            echo "Using direct commit ID '${imageTag}' for ${serviceName}."
                        } else {
                            try {
                                sh "git fetch origin \"${branchOrCommit}\" --depth=1"
                                imageTag = sh(script: "git rev-parse --short \"origin/${branchOrCommit}\"", returnStdout: true).trim()
                                echo "Resolved branch '${branchOrCommit}' to commit ID '${imageTag}' for ${serviceName}."
                            } catch (Exception e) {
                                echo "Warning: Could not resolve branch '${branchOrCommit}' for service ${serviceName}. Defaulting to 'latest'. Error: ${e.getMessage()}"
                                imageTag = 'latest'
                            }
                        }
                        localTagMap[serviceName] = imageTag
                        env["TAG_${serviceName.toUpperCase().replace('-', '_')}"] = imageTag
                        echo "Stored image tag for ${serviceName}: ${imageTag}"
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {

                    sh "kubectl create namespace \"${params.TARGET_NAMESPACE}\" --dry-run=client -o yaml | kubectl apply -f -"
                    
                    def manifestFiles = [
                        'discovery-server',
                        'admin-server',
                        'api-gateway',
                        'customers-service',
                        'vets-service',
                        'visits-service',
                        'genai-service'
                    ]

                    manifestFiles.each { serviceKey ->
                        def serviceEnvKeyForTag = "TAG_${serviceKey.toUpperCase().replace('-', '_')}"
                        def currentImageTag = env[serviceEnvKeyForTag] ?: 'latest'
                        
                        def manifestFile = "k8s/${serviceKey}.yaml"
                        if (fileExists(manifestFile)) {
                            echo "Deploying ${manifestFile} with image tag ${currentImageTag} for service ${serviceKey}..."
                            
                            def groovyDockerHubUsername = DOCKER_HUB_CREDS_USR 
                            def groovyImageTag = currentImageTag 
                            def groovyTargetNamespace = params.TARGET_NAMESPACE 

                            // Xây dựng các biểu thức sed hoàn chỉnh trong Groovy
                            // Placeholder trong YAML là ${VAR}
                            // Pattern sed cần tìm là \$\{VAR\} (vì $ và {} là đặc biệt với sed)
                            // Để sed nhận được \${VAR}, chuỗi Groovy cần là '\\${VAR}' hoặc dùng Pattern.quote
                            
                            // Cách 1: Dùng \\
                            // def sedCmdUsername = "s~\\\${DOCKER_HUB_USERNAME}~${groovyDockerHubUsername}~g"
                            // def sedCmdTag = "s~\\\${TAG}~${groovyImageTag}~g"
                            // def sedCmdNamespace = "s~namespace: petclinic~namespace: ${groovyTargetNamespace}~g"

                            // Cách 2: Dùng Pattern.quote (an toàn hơn cho placeholder)
                            // và nối chuỗi cẩn thận cho phần replacement
                            def placeholderUsername = "\${DOCKER_HUB_USERNAME}" // Chuỗi chính xác trong YAML
                            def placeholderTag = "\${TAG}"                     // Chuỗi chính xác trong YAML
                            
                            def sedCmdUsername = "s~${Pattern.quote(placeholderUsername)}~${groovyDockerHubUsername}~g"
                            def sedCmdTag = "s~${Pattern.quote(placeholderTag)}~${groovyImageTag}~g"
                            def sedCmdNamespace = "s~namespace:\\s*petclinic~namespace: ${groovyTargetNamespace}~g"


                            // Truyền các lệnh sed này vào shell
                            sh """
                                set -x
                                cat "${manifestFile}" | \\
                                sed -e "${sedCmdUsername}" -e "${sedCmdTag}" -e "${sedCmdNamespace}" > manifest_temp.yaml
                                
                                echo "--- PROCESSED MANIFEST for ${serviceKey} (Jenkins Log) ---"
                                cat manifest_temp.yaml
                                echo "--- END PROCESSED MANIFEST (Jenkins Log) ---"
                                
                                kubectl apply -n "${groovyTargetNamespace}" -f manifest_temp.yaml
                                set +x
                            """
                            
                            if (serviceKey == 'discovery-server' || serviceKey == 'config-server') {
                                echo "Waiting for ${serviceKey} to stabilize..."
                                sh "sleep 30"
                            } else {
                                sh "sleep 5"
                            }
                        } else {
                            echo "Warning: Manifest file ${manifestFile} not found. Skipping."
                        }
                    }
                    
                    def apiGatewayNodePortManifest = "k8s/api-gateway-nodeport.yaml"
                    if (fileExists(apiGatewayNodePortManifest)) {
                        def groovyTargetNamespaceForNodePort = params.TARGET_NAMESPACE
                        def sedCmdNodeportNamespace = "s~namespace:\\s*petclinic~namespace: ${groovyTargetNamespaceForNodePort}~g"
                        sh """
                            set -x
                            cat "${apiGatewayNodePortManifest}" | \\
                            sed -e "${sedCmdNodeportNamespace}" > nodeport_temp.yaml
                            
                            kubectl apply -n "${groovyTargetNamespaceForNodePort}" -f nodeport_temp.yaml
                            set +x
                        """
                    } else {
                        echo "Warning: API Gateway NodePort manifest ${apiGatewayNodePortManifest} not found."
                    }

                    def workerNodeIP = sh(script: 'kubectl get nodes -l \'!node-role.kubernetes.io/control-plane\' -o jsonpath=\'{.items[0].status.addresses[?(@.type=="InternalIP")].address}\'', returnStdout: true).trim()
                    def nodePort = sh(script: "kubectl get svc api-gateway-nodeport -n \"${params.TARGET_NAMESPACE}\" -o jsonpath='{.spec.ports[0].nodePort}'", returnStdout: true).trim()

                    if (workerNodeIP.isEmpty() || nodePort.isEmpty()) {
                        echo "Could not determine Worker Node IP or NodePort. Please check manually."
                    } else {
                        echo "====================================================="
                        // ... (phần echo thông tin truy cập)
                    }
                }
            }
        }
    }
    
    post {
        always {
            echo "CD Pipeline finished."
            sh "rm -f manifest_temp.yaml nodeport_temp.yaml || true"
        }
    }
}